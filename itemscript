import random
import yaml
import sys
import curses


def roll_dice_pool(dice_pool, nine_again=False, eight_again=False):
    successes = 0
    rolls = []
    while dice_pool > 0:
        roll = random.randint(1, 10)
        rolls.append(roll)
        
        # Count successes
        if roll >= 8:
            successes += 1
            
        # Handle 10-again rule (always in effect)
        if roll == 10:
            dice_pool += 1
            
        # Handle 9-again rule
        elif nine_again and roll >= 9:
            dice_pool += 1
            
        # Handle 8-again rule
        elif eight_again and roll >= 8:
            dice_pool += 1
        
        # Reduce dice pool for the next iteration
        dice_pool -= 1
    
    return successes, rolls

def create_awakened_item(config=None):
    if config is None:
        config = {}
    
     # Gather necessary inputs
    print(config.get('gnosis'))
    
    gnosis = int(config.get('gnosis') if config.get('gnosis') else input("Enter the mage's Gnosis: "))
    mage_arcana = int(config.get('mage_arcana') if config.get('mage_arcana') else input("Enter the Arcana level of the mage: "))
    highest_arcanum = int(config.get('highest_arcanum') if config.get('highest_arcanum') else input("Enter the items's highest Arcana level: "))
    yantras = int(config.get('yantras') if config.get('yantras') else input("Enter the total bonus from item Yantras(including chanting)): "))
    places_of_power = int(config.get('places_of_power') if config.get('places_of_power') else input("Enter the bonus from Places of Power: "))
    supporting_crafters = int(config.get('supporting_crafters') if config.get('supporting_crafters') else input("Enter the bonus from Supporting Crafters: "))
    is_persistent = config.get('is_persistent') if isinstance(config.get('is_persistent'), bool) else input("is the item Persistent? (yes/no): ") == 'yes'
    if not is_persistent:
        duration_penalty = abs(int(config.get('duration_penalty') if config.get('duration_penalty') else  input("what is the dice penalty for duration if any (ie: -4): ")))
    is_duration_reach = config.get('is_duration_reach') if isinstance(config.get('is_duration_reach'), bool) else input("Did you reach for Advanced Duration? (yes/no): ") == 'yes'
    primary_factor = config.get('primary_factor') if config.get('primary_factor') else input("What is the Primary Factor? (a Potency/b Duration): ") == 'yes' ### TODO
    extra_reaches = int(config.get('extra_reaches') if config.get('extra_reaches') else input("Enter any additional reaches for the spell: "))
    mana_battery = int(config.get('mana_battery') if config.get('mana_battery') else input("How many mana beyond the default 1 will it hold? (even numbers only): "))
    prior_craftings = int(config.get('prior_craftings') if config.get('prior_craftings') else input("How many total arcana have been put into item on prior craftings? "))
    is_praxis = config.get('is_praxis') if isinstance(config.get('is_praxis'), bool) else input("Is the spell a Praxis? (yes/no): ") == 'yes'
    is_perfected = config.get('is_perfected') if isinstance(config.get('is_perfected'), bool) else input("Is the material an appropriate perfected material? (yes/no): ") == 'yes'
    potency = int(config.get('potency') if config.get('potency') else input("Enter the potency of the spell: "))
    spell_range = input(config.get('spell_range') if config.get('spell_range') else "Enter the type of range (a for self/touch, b for sensory, c for aimed): ") ### TODO
    is_sympathetic = False
    is_temporal_sympathy = False
    if spell_range == 'b':
        is_sympathetic = config.get('is_sympathetic') if isinstance(config.get('is_sympathetic'),bool)  else  input("Is it a sympathetic range? (yes/no): ") == 'yes'
        is_temporal_sympathy = config.get('is_temporal_sympathy') if isinstance(config.get('is_temporal_sympathy'), bool) else  input("Is it a temporal sympathy? (yes/no): ") == 'yes'
    
    # Calculate total dice pool and required successes
    duration_penalty = calc_duration_penalty(primary_factor, is_persistent, mage_arcana, is_duration_reach, config)
    potency_penalty = calc_potency_successes(primary_factor, potency, mage_arcana)
    perfected_bonus = False
    if is_perfected:
        perfected_bonus = True
    end_bonus = places_of_power + supporting_crafters + yantras
    dice_pool = gnosis + mage_arcana
    required_successes = (potency_penalty +
                          duration_penalty +
                          extra_reaches +
                          int(mana_battery/2) +
                          prior_craftings +
                          highest_arcanum)
    if is_persistent:
        required_successes += 10  # +10 for indefinite duration in advanced chart
    else:
        required_successes += duration_penalty
    if is_sympathetic:
        required_successes += 1
    if is_temporal_sympathy:
        required_successes += 1
    if spell_range == 'b':
        required_successes += 1  # Sensory range costs additional success
    if is_praxis:
        end_bonus += 1
    
    # Inform the user about the goal
    print(f"\nGoal: Achieve {required_successes} successes.")
    
    # Rolling process
    total_successes = 0
    exceptional_successes = 0
    failures = 0
    
    # Track all rolls for reporting
    all_rolls = []
    
    for i in range(gnosis + mage_arcana):
        if (total_successes + end_bonus) < required_successes:
            successes, rolls = roll_dice_pool(dice_pool, nine_again=perfected_bonus)
            all_rolls.extend(rolls)
            
            # Check for exceptional success or failure on this roll
            if successes >= 5:
                exceptional_successes += 1
            if successes == 0:
                failures += 1
                
            total_successes += successes
            print(f"Roll {i+1}: {rolls} => {successes} successes")
    
    # Final results
    print(f"\nEnd Bonus successes: {end_bonus}")
    print(f"\nRolled successes: {total_successes}")
    print(f"\nTotal successes: {(total_successes + end_bonus)}")
    if exceptional_successes > 0:
        print(f"Exceptional successes: {exceptional_successes}")
    if failures > 0:
        print(f"Failures: {failures}")

    if (total_successes + end_bonus) >= required_successes:
        print("\nItem creation successful!")
    else:
        print("\nItem creation failed!")
    
    return total_successes

# (a Potency/b Duration)
def calc_potency_successes(primary_factor, potency, mage_arcana):
    additional_potency_successes = 0
    match primary_factor:
        case "a":
            potency = max((potency-mage_arcana)*2, 0) #potency successes never below 0
        case "b":
            potency = max((potency-1)*2, 0)
            
def calc_duration_penalty(primary_factor, is_persistent, mage_arcana, is_duration_reach, config):
    duration_penalty = 0
    if is_persistent and not is_duration_reach:
        exit_with_error("Bad Request - If item is persistant, then you must use the advanced duration chart.")
    else:
        duration_penalty = curses.wrapper(choose_duration_index, mage_arcana, is_duration_reach)
    
    if not is_duration_reach:
        print(curses.wrapper(choose_duration_index, mage_arcana, is_duration_reach))
        
    return duration_penalty

def choose_duration_index(stdscr, mage_arcana, is_duration_reach):
    curses.curs_set(0)  # Hide cursor
    stdscr.keypad(1)   # Enable special keys
    
    options = generate_standard_duration_array(mage_arcana) if is_duration_reach else generate_advanced_duration_array(mage_arcana)

    
    index = 0
    while True:
        stdscr.clear()
        for i, option in enumerate(options):
            if i == index:
                stdscr.addstr(i, 0, option, curses.A_REVERSE)
            else:
                stdscr.addstr(i, 0, option)

        key = stdscr.getch()

        if key == curses.KEY_DOWN:
            index += 1
            if index == len(options):
                # Calculate the new option based on the last option
                turns = int(options[-1].split()[0]) + 10
                dice = int(options[-1].split()[-2].replace('(', '').replace('-', ''))
                new_option = f"{turns} turns ({dice} dice)"
                options.append(new_option)
        elif key == curses.KEY_UP and index > 0:
            index -= 1
        elif key == curses.KEY_ENTER or key in [10, 13]:
            return index

def generate_standard_duration_array(number):
    # Define the initial pattern for turns
    turns_pattern = list(range(1, number + 1)) + list(range(number + 10, number * 10 + 10, 10))
    
    # Construct the array
    array = []
    dice_penalty = 0
    for turns in turns_pattern:
        # Add the dice penalty only after reaching the given number
        if turns > number:
            dice_penalty += 2
        array.append(f"{turns} turn{'s' if turns > 1 else ''} (-{dice_penalty} dice)")
    
    return array

def generate_advanced_duration_array(number):
    # Define the time frames and penalties
    time_frames = ["scene/hour", "day", "week", "month", "year", "Indefinite"]
    
    # Start with 0 dice penalty for the specified number of time frames
    dice_penalties = [0] * number + list(range(2, (len(time_frames) - number + 1) * 2, 2))
    
    # Construct the array
    array = []
    for time_frame, dice_penalty in zip(time_frames, dice_penalties):
        if time_frame == "Indefinite":
            array.append(f"{time_frame} (-{dice_penalty} dice)")
        else:
            array.append(f"1 {time_frame} (-{dice_penalty} dice)")
    
    return array

        
def read_yaml_config(file_path):
    with open(file_path, 'r') as file:
        data = yaml.safe_load(file)
    return data

def exit_with_error(message, code=400):
    print(f"Error {code}: {message}")
    sys.exit(code)

def main():
    choice = input("Do you want to provide manual input or use a configuration file? (manual/file): ")
    
    if choice == "manual":
        create_awakened_item()
    elif choice == "file":
        file_path = "./itemconfig.yaml"
        config = read_yaml_config(file_path)
        create_awakened_item(config)
    else:
        print("Invalid choice. Exiting.")

if __name__ == "__main__":
    main()